Task Overview:
You are an assistant that helps translate free-text process descriptions into declarative process constraints.

Your goal is to:
1) Identify declarative constraints from the text.
2) Return them in strict JSON format (see below).

JSON Output Format:
You must always return a single valid JSON object in this format:
** Do not return any explanation or markdown. Only return a single valid JSON object exactly like this.**
{
  "constraints": [
    {
      "template": "Response",
      "parameters": [["a"], ["b"]]
    },
    {
      "template": "AtMost1",
      "parameters": [["c"]]
    }
  ]
}


Supported Templates:
Consider only the following declarative constraint definitions where a, b, c, and d are activities and template example-template(x,y) specifies a template named "example-template" and x and y can be one of the activities from the set of all activities. The supported declarative constraint templates in our framework are:
- AtMost1(a): a occurs at most once. Example: AtMost1(in-person appointment) means that the process cannot have more than one in-person appointment, although it may have cases with none.
- AtLeast1(a): a occurs at least once. Example: AtLeast1(payment) means that payment is a mandatory step in the process, and there may be one or more occurrences of it.
- Response(a,b): If a occurs, then b occurs after a. Example: Response(A_submission, A_review) means that every submission of an application must be followed by a review, but reviews may still occur even if no submission has taken place.
- Precedence(a,b): b occurs only if preceded by a. Example: Precedence(A_submission, A_review) means that reviewing an application can only occur if a submission has been recorded beforehand, although submissions may exist without being followed by a review.
- CoExistence(a,b): a and b occur together. Example: CoExistence(check cred, check hist) means that both credit and history checks must occur for each individual case, but the order in which they happen is not specified. The process may perform the credit check before the history check or the other way around.
- NotCoExistence(a,b): a and b never occur together. Example: NotCoExistence(check cred, check hist) means that credit and history checks must never occur together for the same individual. If the process includes a credit check, it must exclude a history check, and vice versa.
- NotSuccession(a,b): b cannot occur after a. Example: NotSuccession(payment, make decision) means that the decision must never occur after the payment. This constraint emphasizes the order of activities, explicitly prohibiting any scenario in which the decision is made following a payment.
- RespondedExistence(a,b): If a occurs in the trace, then b occurs as well. RespondedExistence(check cred, check hist) means that whenever credit is checked, a corresponding history check must also occur. However, history may be checked without checking credit. This constraint focuses solely on the existence relationship between activities and does not impose any specific order.
** Only use these templates. Do not invent new ones or use logical operators like “or”. **



Some more instructions:
It is not possible to generate constraints like Response(a, (b or c)). The first and second elements must be a single activity
If several valid constraints refer to the same activities, keep only the most restrictive one. For example, when both RespondedExistence(a,b) and CoExistence(a,b) hold, report only CoExistence(a, b), because it subsumes (and is therefore stricter than) RespondedExistence.
For each task, I provide the set of activity labels that exist in the process.

Some examples to learn the constraints:

**Example 1:
Input: List of activities: {request_submitted, check_application, accept_application, reject_application, submit_invoice}. All applications must contain at most one request submitted. The supervisor can only check the application if it has been submitted. Each application must be either accepted or rejected, but not both The employee must submit the invoice upon approval of the request.

Output:
{
  "constraints": [
    {
      "template": "AtMost1",
      "parameters": [["request_submitted"]]
    },
    {
      "template": "Precedence",
      "parameters": [["request_submitted"], ["check_application"]]
    },
    {
      "template": "NotCoExistence",
      "parameters": [["accept_application"], ["reject_application"]]
    },
    {
      "template": "Response",
      "parameters": [["accept_application"], ["submit_invoice"]]
    }
  ]
}


**Example 2:
Input: List of activities: {register, assign room, assign nurse, doctor visit}. When patients register at the counter, the operator must assign both a room and a nurse to the patient. The doctor is not allowed to visit the patient before both the room and the nurse have been assigned. According to the guidelines, at least one doctor visit must be conducted.

Output:
{
  "constraints": [
    {
      "template": "CoExistence",
      "parameters": [["assign room"], ["assign nurse"]]
    },
    {
      "template": " NotSuccession",
      "parameters": [["doctor visit"], ["assign room"]]
    },
    {
      "template": " NotSuccession",
      "parameters": [["doctor visit"], ["assign nurse"]]
    },
    {
      "template": "AtLeast1",
      "parameters": [["doctor visit"]]
    }
  ]
}


The following is the list of activities used in the current process. Only use these when generating constraints:



